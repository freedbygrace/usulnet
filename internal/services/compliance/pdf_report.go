// SPDX-License-Identifier: AGPL-3.0-or-later
// Copyright (c) 2024-2026 usulnet contributors
// https://github.com/fr4nsys/usulnet

package compliance

import (
	"bytes"
	"fmt"
	"strings"
	"time"
)

// renderPDFReport generates a minimal but valid PDF compliance report without
// external dependencies.  The resulting PDF uses only the standard Helvetica
// font family and produces text-based content that is searchable and
// copy-pasteable.
func (s *Service) renderPDFReport(p reportPayload) ([]byte, error) {
	pdf := newPDFWriter()

	// Page 1: Cover
	pdf.addPage()
	pdf.setFont("Helvetica-Bold", 24)
	pdf.drawText(72, 700, p.Framework.DisplayName)
	pdf.setFont("Helvetica", 16)
	pdf.drawText(72, 670, "Compliance Assessment Report")
	pdf.setFont("Helvetica", 11)
	pdf.drawText(72, 630, fmt.Sprintf("Assessment: %s", p.Assessment.Name))
	pdf.drawText(72, 614, fmt.Sprintf("Started: %s", p.Assessment.StartedAt.Format(time.RFC3339)))
	completedAt := "In Progress"
	if p.Assessment.CompletedAt != nil {
		completedAt = p.Assessment.CompletedAt.Format(time.RFC3339)
	}
	pdf.drawText(72, 598, fmt.Sprintf("Completed: %s", completedAt))
	pdf.drawText(72, 582, fmt.Sprintf("Generated: %s", p.GeneratedAt.Format(time.RFC3339)))

	// Executive Summary
	pdf.setFont("Helvetica-Bold", 14)
	pdf.drawText(72, 540, "Executive Summary")
	pdf.setFont("Helvetica", 11)
	pdf.drawText(72, 520, fmt.Sprintf("Compliance Score: %.1f%%", p.Assessment.Score))
	pdf.drawText(72, 504, fmt.Sprintf("Total Controls: %d", p.Assessment.TotalControls))
	pdf.drawText(72, 488, fmt.Sprintf("Passed: %d", p.Assessment.PassedControls))
	pdf.drawText(72, 472, fmt.Sprintf("Failed: %d", p.Assessment.FailedControls))
	pdf.drawText(72, 456, fmt.Sprintf("Not Applicable: %d", p.Assessment.NAControls))
	manualReview := p.Assessment.TotalControls - p.Assessment.PassedControls - p.Assessment.FailedControls - p.Assessment.NAControls
	if manualReview > 0 {
		pdf.drawText(72, 440, fmt.Sprintf("Manual Review Required: %d", manualReview))
	}

	// Page 2+: Control Results
	if len(p.Results) > 0 {
		pdf.addPage()
		pdf.setFont("Helvetica-Bold", 14)
		pdf.drawText(72, 740, "Control Results")

		y := 710.0
		lineHeight := 14.0
		pageBottom := 60.0

		// Table header
		pdf.setFont("Helvetica-Bold", 9)
		pdf.drawText(72, y, "Control ID")
		pdf.drawText(170, y, "Control Name")
		pdf.drawText(370, y, "Status")
		pdf.drawText(440, y, "Details")
		y -= lineHeight

		// Draw header line
		pdf.drawLine(72, y+2, 540, y+2)
		y -= 4

		pdf.setFont("Helvetica", 8)
		for _, r := range p.Results {
			if y < pageBottom {
				pdf.addPage()
				y = 740
				pdf.setFont("Helvetica-Bold", 9)
				pdf.drawText(72, y, "Control ID")
				pdf.drawText(170, y, "Control Name")
				pdf.drawText(370, y, "Status")
				pdf.drawText(440, y, "Details")
				y -= lineHeight
				pdf.drawLine(72, y+2, 540, y+2)
				y -= 4
				pdf.setFont("Helvetica", 8)
			}

			// Truncate long strings to fit the page
			name := truncateStr(r.ControlName, 40)
			details := truncateStr(r.Details, 22)
			statusLabel := formatStatus(r.Status)

			pdf.drawText(72, y, r.ControlID)
			pdf.drawText(170, y, name)
			pdf.drawText(370, y, statusLabel)
			pdf.drawText(440, y, details)
			y -= lineHeight
		}
	}

	// Footer on last page
	pdf.setFont("Helvetica", 8)
	pdf.drawText(72, 30, fmt.Sprintf("Generated by usulnet on %s", p.GeneratedAt.Format(time.RFC3339)))

	return pdf.render(), nil
}

func formatStatus(s string) string {
	switch s {
	case "pass":
		return "PASS"
	case "fail":
		return "FAIL"
	case "not_applicable":
		return "N/A"
	case "manual_review_required":
		return "MANUAL REVIEW"
	default:
		return strings.ToUpper(s)
	}
}

func truncateStr(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

// ============================================================================
// Minimal PDF writer â€” produces valid PDF 1.4 documents using only built-in
// fonts.  No external dependencies required.
// ============================================================================

type pdfWriter struct {
	buf     bytes.Buffer
	objects []string
	pages   []int // object indices for page objects
	offsets []int // byte offsets for xref

	currentPage int
	pageContent []string

	fontName string
	fontSize float64
}

func newPDFWriter() *pdfWriter {
	return &pdfWriter{
		fontName: "Helvetica",
		fontSize: 11,
	}
}

func (pw *pdfWriter) addPage() {
	// Flush previous page content if any
	if pw.currentPage > 0 {
		pw.flushPage()
	}
	pw.currentPage++
	pw.pageContent = nil
}

func (pw *pdfWriter) setFont(name string, size float64) {
	pw.fontName = name
	pw.fontSize = size
	// Font changes are embedded in the content stream.
	fontRef := "/F1"
	switch name {
	case "Helvetica-Bold":
		fontRef = "/F2"
	}
	pw.pageContent = append(pw.pageContent,
		fmt.Sprintf("BT %s %.1f Tf ET", fontRef, size))
}

func (pw *pdfWriter) drawText(x, y float64, text string) {
	// Escape PDF special characters in strings.
	escaped := pdfEscapeString(text)
	pw.pageContent = append(pw.pageContent,
		fmt.Sprintf("BT %.1f %.1f Td (%s) Tj ET", x, y, escaped))
}

func (pw *pdfWriter) drawLine(x1, y1, x2, y2 float64) {
	pw.pageContent = append(pw.pageContent,
		fmt.Sprintf("%.1f %.1f m %.1f %.1f l S", x1, y1, x2, y2))
}

func (pw *pdfWriter) flushPage() {
	content := strings.Join(pw.pageContent, "\n")
	// Add content stream object (will be referenced by page)
	contentIdx := len(pw.objects) + 1 // +1 because objects are 1-indexed in the final render
	_ = contentIdx
	pw.objects = append(pw.objects, fmt.Sprintf("<< /Length %d >>\nstream\n%s\nendstream", len(content), content))
	pw.pages = append(pw.pages, len(pw.objects)) // content obj index (1-based)
}

func (pw *pdfWriter) render() []byte {
	// Flush last page
	if pw.currentPage > 0 && pw.pageContent != nil {
		pw.flushPage()
	}

	var buf bytes.Buffer
	var offsets []int

	// PDF header
	buf.WriteString("%PDF-1.4\n%\xe2\xe3\xcf\xd3\n")

	// Object 1: Catalog
	offsets = append(offsets, buf.Len())
	buf.WriteString("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n")

	// Object 2: Pages (parent)
	offsets = append(offsets, buf.Len())
	kids := ""
	for i := range pw.pages {
		pageObjNum := 5 + i*2 // page objects start at 5, each page = 2 objects (page + content)
		if i > 0 {
			kids += " "
		}
		kids += fmt.Sprintf("%d 0 R", pageObjNum)
	}
	buf.WriteString(fmt.Sprintf("2 0 obj\n<< /Type /Pages /Kids [%s] /Count %d >>\nendobj\n", kids, len(pw.pages)))

	// Object 3: Font Helvetica
	offsets = append(offsets, buf.Len())
	buf.WriteString("3 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n")

	// Object 4: Font Helvetica-Bold
	offsets = append(offsets, buf.Len())
	buf.WriteString("4 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica-Bold >>\nendobj\n")

	// Page objects: each page = page dict + content stream
	objNum := 5
	for i, contentObjIdx := range pw.pages {
		_ = contentObjIdx

		// Page object
		offsets = append(offsets, buf.Len())
		contentNum := objNum + 1
		buf.WriteString(fmt.Sprintf("%d 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Resources << /Font << /F1 3 0 R /F2 4 0 R >> >> /Contents %d 0 R >>\nendobj\n",
			objNum, contentNum))

		// Content stream object
		offsets = append(offsets, buf.Len())
		content := pw.objects[i] // objects stored in page order
		buf.WriteString(fmt.Sprintf("%d 0 obj\n%s\nendobj\n", contentNum, content))

		objNum += 2
	}

	totalObjects := objNum - 1

	// Cross-reference table
	xrefOffset := buf.Len()
	buf.WriteString("xref\n")
	buf.WriteString(fmt.Sprintf("0 %d\n", totalObjects+1))
	buf.WriteString("0000000000 65535 f \n")
	for _, off := range offsets {
		buf.WriteString(fmt.Sprintf("%010d 00000 n \n", off))
	}

	// Trailer
	buf.WriteString(fmt.Sprintf("trailer\n<< /Size %d /Root 1 0 R >>\nstartxref\n%d\n%%%%EOF\n",
		totalObjects+1, xrefOffset))

	return buf.Bytes()
}

// pdfEscapeString escapes characters that are special in PDF string literals.
func pdfEscapeString(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "(", "\\(")
	s = strings.ReplaceAll(s, ")", "\\)")
	return s
}
