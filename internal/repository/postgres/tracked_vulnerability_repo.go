// SPDX-License-Identifier: AGPL-3.0-or-later
// Copyright (c) 2024-2026 usulnet contributors
// https://github.com/fr4nsys/usulnet

package postgres

import (
	"context"
	"time"

	"github.com/fr4nsys/usulnet/internal/models"
	"github.com/google/uuid"
)

// Type alias pointing to shared model type.
type TrackedVulnerability = models.TrackedVulnRecord

// TrackedVulnerabilityRepository handles CRUD for tracked vulnerabilities.
type TrackedVulnerabilityRepository struct {
	db *DB
}

// NewTrackedVulnerabilityRepository creates a new tracked vulnerability repository.
func NewTrackedVulnerabilityRepository(db *DB) *TrackedVulnerabilityRepository {
	return &TrackedVulnerabilityRepository{db: db}
}

// Create creates a new tracked vulnerability.
func (r *TrackedVulnerabilityRepository) Create(ctx context.Context, v *TrackedVulnerability) error {
	if v.ID == uuid.Nil {
		v.ID = uuid.New()
	}
	_, err := r.db.Exec(ctx, `
		INSERT INTO tracked_vulnerabilities (id, cve_id, title, description, severity, cvss_score,
			package, installed_ver, fixed_ver, affected_images, container_count,
			status, priority, sla_deadline, assignee, notes, detected_at)
		VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17)
		ON CONFLICT (cve_id) DO NOTHING`,
		v.ID, v.CVEID, v.Title, v.Description, v.Severity, v.CVSSScore,
		v.Package, v.InstalledVer, v.FixedVer, v.AffectedImages, v.ContainerCount,
		v.Status, v.Priority, v.SLADeadline, v.Assignee, v.Notes, v.DetectedAt,
	)
	return err
}

// GetByID retrieves a vulnerability by ID.
func (r *TrackedVulnerabilityRepository) GetByID(ctx context.Context, id uuid.UUID) (*TrackedVulnerability, error) {
	v := &TrackedVulnerability{}
	err := r.db.QueryRow(ctx, `
		SELECT id, cve_id, title, description, severity, cvss_score, package, installed_ver, fixed_ver,
			affected_images, container_count, status, priority, sla_deadline, assignee, notes,
			detected_at, resolved_at, created_at, updated_at
		FROM tracked_vulnerabilities WHERE id = $1`, id).Scan(
		&v.ID, &v.CVEID, &v.Title, &v.Description, &v.Severity, &v.CVSSScore,
		&v.Package, &v.InstalledVer, &v.FixedVer, &v.AffectedImages, &v.ContainerCount,
		&v.Status, &v.Priority, &v.SLADeadline, &v.Assignee, &v.Notes,
		&v.DetectedAt, &v.ResolvedAt, &v.CreatedAt, &v.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}
	return v, nil
}

// GetByCVE retrieves a vulnerability by CVE ID.
func (r *TrackedVulnerabilityRepository) GetByCVE(ctx context.Context, cveID string) (*TrackedVulnerability, error) {
	v := &TrackedVulnerability{}
	err := r.db.QueryRow(ctx, `
		SELECT id, cve_id, title, description, severity, cvss_score, package, installed_ver, fixed_ver,
			affected_images, container_count, status, priority, sla_deadline, assignee, notes,
			detected_at, resolved_at, created_at, updated_at
		FROM tracked_vulnerabilities WHERE cve_id = $1`, cveID).Scan(
		&v.ID, &v.CVEID, &v.Title, &v.Description, &v.Severity, &v.CVSSScore,
		&v.Package, &v.InstalledVer, &v.FixedVer, &v.AffectedImages, &v.ContainerCount,
		&v.Status, &v.Priority, &v.SLADeadline, &v.Assignee, &v.Notes,
		&v.DetectedAt, &v.ResolvedAt, &v.CreatedAt, &v.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}
	return v, nil
}

// List returns all tracked vulnerabilities.
func (r *TrackedVulnerabilityRepository) List(ctx context.Context) ([]*TrackedVulnerability, error) {
	rows, err := r.db.Query(ctx, `
		SELECT id, cve_id, title, description, severity, cvss_score, package, installed_ver, fixed_ver,
			affected_images, container_count, status, priority, sla_deadline, assignee, notes,
			detected_at, resolved_at, created_at, updated_at
		FROM tracked_vulnerabilities ORDER BY detected_at DESC`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var vulns []*TrackedVulnerability
	for rows.Next() {
		v := &TrackedVulnerability{}
		if err := rows.Scan(
			&v.ID, &v.CVEID, &v.Title, &v.Description, &v.Severity, &v.CVSSScore,
			&v.Package, &v.InstalledVer, &v.FixedVer, &v.AffectedImages, &v.ContainerCount,
			&v.Status, &v.Priority, &v.SLADeadline, &v.Assignee, &v.Notes,
			&v.DetectedAt, &v.ResolvedAt, &v.CreatedAt, &v.UpdatedAt,
		); err != nil {
			return nil, err
		}
		vulns = append(vulns, v)
	}
	return vulns, nil
}

// UpdateStatus updates a vulnerability's status.
func (r *TrackedVulnerabilityRepository) UpdateStatus(ctx context.Context, id uuid.UUID, status string) error {
	if status == "resolved" {
		now := time.Now()
		_, err := r.db.Exec(ctx, `
			UPDATE tracked_vulnerabilities SET status=$2, resolved_at=$3 WHERE id=$1`,
			id, status, now,
		)
		return err
	}
	_, err := r.db.Exec(ctx, `UPDATE tracked_vulnerabilities SET status=$2 WHERE id=$1`, id, status)
	return err
}

// ExistsByCVE checks if a CVE is already tracked.
func (r *TrackedVulnerabilityRepository) ExistsByCVE(ctx context.Context, cveID string) (bool, error) {
	var exists bool
	err := r.db.QueryRow(ctx, `SELECT EXISTS(SELECT 1 FROM tracked_vulnerabilities WHERE cve_id=$1)`, cveID).Scan(&exists)
	return exists, err
}

// CountByStatus returns vulnerability counts grouped by status.
func (r *TrackedVulnerabilityRepository) CountByStatus(ctx context.Context) (map[string]int, error) {
	rows, err := r.db.Query(ctx, `SELECT status, COUNT(*) FROM tracked_vulnerabilities GROUP BY status`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	counts := make(map[string]int)
	for rows.Next() {
		var status string
		var count int
		if err := rows.Scan(&status, &count); err != nil {
			return nil, err
		}
		counts[status] = count
	}
	return counts, nil
}

// CountBySeverity returns vulnerability counts grouped by severity.
func (r *TrackedVulnerabilityRepository) CountBySeverity(ctx context.Context) (map[string]int, error) {
	rows, err := r.db.Query(ctx, `SELECT severity, COUNT(*) FROM tracked_vulnerabilities GROUP BY severity`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	counts := make(map[string]int)
	for rows.Next() {
		var severity string
		var count int
		if err := rows.Scan(&severity, &count); err != nil {
			return nil, err
		}
		counts[severity] = count
	}
	return counts, nil
}

// CountSLABreached returns count of vulnerabilities with breached SLAs.
func (r *TrackedVulnerabilityRepository) CountSLABreached(ctx context.Context) (int, error) {
	var count int
	err := r.db.QueryRow(ctx, `
		SELECT COUNT(*) FROM tracked_vulnerabilities
		WHERE sla_deadline IS NOT NULL AND sla_deadline < NOW()
		AND status NOT IN ('resolved', 'accepted_risk')`).Scan(&count)
	return count, err
}

// CountResolvedSince returns count of vulnerabilities resolved since the given time.
func (r *TrackedVulnerabilityRepository) CountResolvedSince(ctx context.Context, since time.Time) (int, error) {
	var count int
	err := r.db.QueryRow(ctx, `
		SELECT COUNT(*) FROM tracked_vulnerabilities
		WHERE resolved_at IS NOT NULL AND resolved_at >= $1`, since).Scan(&count)
	return count, err
}
