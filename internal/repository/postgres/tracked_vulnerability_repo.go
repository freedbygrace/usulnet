// SPDX-License-Identifier: AGPL-3.0-or-later
// Copyright (c) 2024-2026 usulnet contributors
// https://github.com/fr4nsys/usulnet

package postgres

import (
	"context"
	"time"

	"github.com/fr4nsys/usulnet/internal/models"
	"github.com/google/uuid"
)

// Type alias pointing to shared model type.
type TrackedVulnerability = models.TrackedVulnRecord

// Column list shared across SELECT queries. Must match the Scan call order.
const trackedVulnCols = `id, cve_id, title, description, severity, cvss_score,
	package, installed_ver, fixed_ver, affected_images, container_count,
	status, priority, sla_deadline, assignee, assignee_id, notes,
	resolution_notes, resolved_scan_id, detected_at, resolved_at,
	created_at, updated_at`

// scanVuln scans a single row into a TrackedVulnerability.
func scanVuln(scanner interface{ Scan(dest ...interface{}) error }) (*TrackedVulnerability, error) {
	v := &TrackedVulnerability{}
	err := scanner.Scan(
		&v.ID, &v.CVEID, &v.Title, &v.Description, &v.Severity, &v.CVSSScore,
		&v.Package, &v.InstalledVer, &v.FixedVer, &v.AffectedImages, &v.ContainerCount,
		&v.Status, &v.Priority, &v.SLADeadline, &v.Assignee, &v.AssigneeID, &v.Notes,
		&v.ResolutionNotes, &v.ResolvedScanID, &v.DetectedAt, &v.ResolvedAt,
		&v.CreatedAt, &v.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}
	return v, nil
}

// TrackedVulnerabilityRepository handles CRUD for tracked vulnerabilities.
type TrackedVulnerabilityRepository struct {
	db *DB
}

// NewTrackedVulnerabilityRepository creates a new tracked vulnerability repository.
func NewTrackedVulnerabilityRepository(db *DB) *TrackedVulnerabilityRepository {
	return &TrackedVulnerabilityRepository{db: db}
}

// Create creates a new tracked vulnerability (inserts only, skips if CVE already exists).
func (r *TrackedVulnerabilityRepository) Create(ctx context.Context, v *TrackedVulnerability) error {
	if v.ID == uuid.Nil {
		v.ID = uuid.New()
	}
	_, err := r.db.Exec(ctx, `
		INSERT INTO tracked_vulnerabilities (id, cve_id, title, description, severity, cvss_score,
			package, installed_ver, fixed_ver, affected_images, container_count,
			status, priority, sla_deadline, assignee, notes, detected_at)
		VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17)
		ON CONFLICT (cve_id) DO NOTHING`,
		v.ID, v.CVEID, v.Title, v.Description, v.Severity, v.CVSSScore,
		v.Package, v.InstalledVer, v.FixedVer, v.AffectedImages, v.ContainerCount,
		v.Status, v.Priority, v.SLADeadline, v.Assignee, v.Notes, v.DetectedAt,
	)
	return err
}

// Upsert creates or updates a tracked vulnerability. On conflict (same CVE ID),
// it updates the mutable scan data (affected images, container count, severity,
// CVSS, package info) while preserving user-managed fields (status, priority,
// SLA, assignee, notes).
func (r *TrackedVulnerabilityRepository) Upsert(ctx context.Context, v *TrackedVulnerability) error {
	if v.ID == uuid.Nil {
		v.ID = uuid.New()
	}
	_, err := r.db.Exec(ctx, `
		INSERT INTO tracked_vulnerabilities (id, cve_id, title, description, severity, cvss_score,
			package, installed_ver, fixed_ver, affected_images, container_count,
			status, priority, sla_deadline, assignee, notes, detected_at)
		VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17)
		ON CONFLICT (cve_id) DO UPDATE SET
			title = EXCLUDED.title,
			description = EXCLUDED.description,
			severity = EXCLUDED.severity,
			cvss_score = EXCLUDED.cvss_score,
			package = EXCLUDED.package,
			installed_ver = EXCLUDED.installed_ver,
			fixed_ver = EXCLUDED.fixed_ver,
			affected_images = EXCLUDED.affected_images,
			container_count = EXCLUDED.container_count`,
		v.ID, v.CVEID, v.Title, v.Description, v.Severity, v.CVSSScore,
		v.Package, v.InstalledVer, v.FixedVer, v.AffectedImages, v.ContainerCount,
		v.Status, v.Priority, v.SLADeadline, v.Assignee, v.Notes, v.DetectedAt,
	)
	return err
}

// GetByID retrieves a vulnerability by ID.
func (r *TrackedVulnerabilityRepository) GetByID(ctx context.Context, id uuid.UUID) (*TrackedVulnerability, error) {
	row := r.db.QueryRow(ctx, `SELECT `+trackedVulnCols+` FROM tracked_vulnerabilities WHERE id = $1`, id)
	return scanVuln(row)
}

// GetByCVE retrieves a vulnerability by CVE ID.
func (r *TrackedVulnerabilityRepository) GetByCVE(ctx context.Context, cveID string) (*TrackedVulnerability, error) {
	row := r.db.QueryRow(ctx, `SELECT `+trackedVulnCols+` FROM tracked_vulnerabilities WHERE cve_id = $1`, cveID)
	return scanVuln(row)
}

// List returns all tracked vulnerabilities.
func (r *TrackedVulnerabilityRepository) List(ctx context.Context) ([]*TrackedVulnerability, error) {
	rows, err := r.db.Query(ctx, `SELECT `+trackedVulnCols+` FROM tracked_vulnerabilities ORDER BY detected_at DESC`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var vulns []*TrackedVulnerability
	for rows.Next() {
		v, err := scanVuln(rows)
		if err != nil {
			return nil, err
		}
		vulns = append(vulns, v)
	}
	return vulns, nil
}

// UpdateStatus updates a vulnerability's status.
func (r *TrackedVulnerabilityRepository) UpdateStatus(ctx context.Context, id uuid.UUID, status string) error {
	if status == "resolved" {
		now := time.Now()
		_, err := r.db.Exec(ctx, `
			UPDATE tracked_vulnerabilities SET status=$2, resolved_at=$3 WHERE id=$1`,
			id, status, now,
		)
		return err
	}
	_, err := r.db.Exec(ctx, `UPDATE tracked_vulnerabilities SET status=$2 WHERE id=$1`, id, status)
	return err
}

// Resolve marks a vulnerability as resolved with resolution evidence.
func (r *TrackedVulnerabilityRepository) Resolve(ctx context.Context, id uuid.UUID, notes string, scanID *uuid.UUID) error {
	now := time.Now()
	_, err := r.db.Exec(ctx, `
		UPDATE tracked_vulnerabilities
		SET status = 'resolved', resolved_at = $2, resolution_notes = $3, resolved_scan_id = $4
		WHERE id = $1`,
		id, now, notes, scanID,
	)
	return err
}

// Assign assigns a vulnerability to a user.
func (r *TrackedVulnerabilityRepository) Assign(ctx context.Context, id uuid.UUID, assigneeID *uuid.UUID, assigneeName string) error {
	_, err := r.db.Exec(ctx, `
		UPDATE tracked_vulnerabilities SET assignee_id = $2, assignee = $3 WHERE id = $1`,
		id, assigneeID, assigneeName,
	)
	return err
}

// ListSLABreached returns vulnerabilities whose SLA deadline has passed.
func (r *TrackedVulnerabilityRepository) ListSLABreached(ctx context.Context) ([]*TrackedVulnerability, error) {
	rows, err := r.db.Query(ctx, `
		SELECT `+trackedVulnCols+`
		FROM tracked_vulnerabilities
		WHERE sla_deadline IS NOT NULL AND sla_deadline < NOW()
		AND status NOT IN ('resolved', 'accepted_risk')
		ORDER BY sla_deadline ASC`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var vulns []*TrackedVulnerability
	for rows.Next() {
		v, err := scanVuln(rows)
		if err != nil {
			return nil, err
		}
		vulns = append(vulns, v)
	}
	return vulns, nil
}

// WeeklyTrend returns vulnerability open/close trend data from the view.
func (r *TrackedVulnerabilityRepository) WeeklyTrend(ctx context.Context) ([]models.VulnWeeklyTrend, error) {
	rows, err := r.db.Query(ctx, `SELECT week, opened, resolved_same_week FROM vuln_weekly_trend`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var trends []models.VulnWeeklyTrend
	for rows.Next() {
		var t models.VulnWeeklyTrend
		if err := rows.Scan(&t.Week, &t.Opened, &t.ResolvedSameWeek); err != nil {
			return nil, err
		}
		trends = append(trends, t)
	}
	return trends, nil
}

// TopAffectedImages returns the top N images with the most open vulnerabilities.
func (r *TrackedVulnerabilityRepository) TopAffectedImages(ctx context.Context, limit int) ([]models.ImageVulnCount, error) {
	if limit <= 0 {
		limit = 10
	}
	rows, err := r.db.Query(ctx, `
		SELECT img, COUNT(*) AS cnt
		FROM tracked_vulnerabilities, unnest(affected_images) AS img
		WHERE status NOT IN ('resolved', 'accepted_risk')
		GROUP BY img
		ORDER BY cnt DESC
		LIMIT $1`, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var result []models.ImageVulnCount
	for rows.Next() {
		var iv models.ImageVulnCount
		if err := rows.Scan(&iv.Image, &iv.Count); err != nil {
			return nil, err
		}
		result = append(result, iv)
	}
	return result, nil
}

// MTTRBySeverity returns the mean time to resolve (in hours) grouped by severity.
func (r *TrackedVulnerabilityRepository) MTTRBySeverity(ctx context.Context) (map[string]float64, error) {
	rows, err := r.db.Query(ctx, `
		SELECT severity,
			EXTRACT(EPOCH FROM AVG(resolved_at - detected_at)) / 3600.0 AS avg_hours
		FROM tracked_vulnerabilities
		WHERE resolved_at IS NOT NULL AND status = 'resolved'
		GROUP BY severity`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := make(map[string]float64)
	for rows.Next() {
		var sev string
		var hours float64
		if err := rows.Scan(&sev, &hours); err != nil {
			return nil, err
		}
		result[sev] = hours
	}
	return result, nil
}

// ExistsByCVE checks if a CVE is already tracked.
func (r *TrackedVulnerabilityRepository) ExistsByCVE(ctx context.Context, cveID string) (bool, error) {
	var exists bool
	err := r.db.QueryRow(ctx, `SELECT EXISTS(SELECT 1 FROM tracked_vulnerabilities WHERE cve_id=$1)`, cveID).Scan(&exists)
	return exists, err
}

// CountByStatus returns vulnerability counts grouped by status.
func (r *TrackedVulnerabilityRepository) CountByStatus(ctx context.Context) (map[string]int, error) {
	rows, err := r.db.Query(ctx, `SELECT status, COUNT(*) FROM tracked_vulnerabilities GROUP BY status`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	counts := make(map[string]int)
	for rows.Next() {
		var status string
		var count int
		if err := rows.Scan(&status, &count); err != nil {
			return nil, err
		}
		counts[status] = count
	}
	return counts, nil
}

// CountBySeverity returns vulnerability counts grouped by severity.
func (r *TrackedVulnerabilityRepository) CountBySeverity(ctx context.Context) (map[string]int, error) {
	rows, err := r.db.Query(ctx, `SELECT severity, COUNT(*) FROM tracked_vulnerabilities GROUP BY severity`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	counts := make(map[string]int)
	for rows.Next() {
		var severity string
		var count int
		if err := rows.Scan(&severity, &count); err != nil {
			return nil, err
		}
		counts[severity] = count
	}
	return counts, nil
}

// CountSLABreached returns count of vulnerabilities with breached SLAs.
func (r *TrackedVulnerabilityRepository) CountSLABreached(ctx context.Context) (int, error) {
	var count int
	err := r.db.QueryRow(ctx, `
		SELECT COUNT(*) FROM tracked_vulnerabilities
		WHERE sla_deadline IS NOT NULL AND sla_deadline < NOW()
		AND status NOT IN ('resolved', 'accepted_risk')`).Scan(&count)
	return count, err
}

// CountResolvedSince returns count of vulnerabilities resolved since the given time.
func (r *TrackedVulnerabilityRepository) CountResolvedSince(ctx context.Context, since time.Time) (int, error) {
	var count int
	err := r.db.QueryRow(ctx, `
		SELECT COUNT(*) FROM tracked_vulnerabilities
		WHERE resolved_at IS NOT NULL AND resolved_at >= $1`, since).Scan(&count)
	return count, err
}

// SLACompliancePercent returns the percentage of resolved vulns that were fixed within SLA.
func (r *TrackedVulnerabilityRepository) SLACompliancePercent(ctx context.Context) (float64, error) {
	var pct float64
	err := r.db.QueryRow(ctx, `
		SELECT COALESCE(
			100.0 * COUNT(*) FILTER (WHERE resolved_at <= sla_deadline)
			/ NULLIF(COUNT(*), 0),
			100.0
		)
		FROM tracked_vulnerabilities
		WHERE status = 'resolved' AND sla_deadline IS NOT NULL`).Scan(&pct)
	return pct, err
}
